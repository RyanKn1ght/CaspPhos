---
title: "Caspase Substrate Analysis"
author: "Ryan Knight"
date: "24/01/2021"
output: 
  bookdown::html_document2:
    fig_caption: yes
    css: "resources/style.css"
bibliography: resources/references.bib
---

<!-- The analysis does knit, but takes a while because of all the extensive. Below: R environment setup -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      results = FALSE,
                      fig.align = "center",
                      fig.retina = 3)
```

```{r requirements}
library(tidyverse) #Data manipulation.
library(reticulate) #Doesn't need to be called to run, but does to knit.
library(ggseqlogo) #Draws sequence logos.
library(patchwork) # Presents plots in grid format.
library(plyr) #Needs call for dplyr::count to work with lapply.


#Selects data to be passed to the phosphate site machine learning model.
source("libraries/preparesites.R") 
#Counts species for conservation chart
source("libraries/countspecies.R")

#Even if python is configured to anaconda in settings, this line must be run in order to knit.
#You probably don't have an environment called this, see readme troubleshooting for conda guidance.
use_condaenv("re-reticulate")

#Threshold (0-1) for evaluation of strength of phosphate site prediction.
#For most purposes 0.5 is sufficient. But it's here so it can be altered and change how the program functions.
phosphate_threshold <- 0.5
```

# Introduction

**Caspases** (**c**ysteine **asp**art**ases**), are a family of proteases that carry out essential roles in forms of programmed cell death. 

Cellular stress and infection promote the assembly of inflammasome complexes, leading to the activation of inflammatory caspases. Activation of these inflammatory caspases, Caspase-1, Caspase-4 and Caspase-5 in humans, and Caspase-1 and Caspase-11 in mice, induces a morphologically distinct form of programmed cell death known as pyroptosis. When undergoing pyroptosis, cells rupture and release their contents, including pro-inflammatory cytokines and danger signals to both prevent intracellular pathogen replication and induce an immune response.

Despite their namesake, there exists substantive evidence that caspases do not exclusively cleave substrates at aspartate residues but have a propensity to act at a variety of other amino acid residues [@seaman_2016], most notably glutamate, possessing similar acidic properties to aspartate.

For our previous work (unpublished data), we compiled a database of inflammatory caspase substrates. As appreciation is developing for the more nuanced nature of caspase cleavage site consensus sequences, this report aims to provide a reproducible analysis and visualisation of features of caspase cleavage sites.

# Methods and Results

<!-- Initial tidying of data -->

```{r tidy}

#Load raw format substrate table. Rename position notation with numbers to identify locations within the shorter sequence better.
file <- "./data/raw/caspase_substrates.csv"
substrates <- read.csv(file) %>% janitor::clean_names()
names(substrates)[c(12:20, 22, 24:33)] <- seq(1, 20)

#Remove columns unnecessary for this application, Tidy up the table names.
# Must call dplyr:: because of confusion with plyr rename (I think.)
sequence_table <- substrates %>% 
  select(uniprot_id, species, cleaved_by, `1`:`9`, `10`, `11`:`20`, 
         concatenated_p10_p10_sequence, human, ape_pantr, mouse, zebrafish_danre) %>%
  dplyr::rename(sequence = concatenated_p10_p10_sequence) %>%

# Strips whitespace that is in the sequence by accident in the standard data set.
# Capitalise sequence in the event that there are some lowercase letters included by mistake.
  mutate(sequence = str_replace(sequence, " ", "")) %>%
  mutate(sequence = toupper(sequence)) %>%
  
# Short sequences with empty spaces (-) cut out as removing - will mis-align them.
# Default dataset contains extra NAs rows in cleaved_by, so they should be removed. 
  filter(!(grepl("-", sequence))) %>%
  na.omit()


#Reduce table down to a list of potential phosphorylation sites (S,T,Y).
# Rearrange into deepphos format.
# This is a second dataset as sequence_table can be used for other things.
potential_sites <- sequence_table %>%
  select(-c(human, ape_pantr, mouse, zebrafish_danre)) %>%
  pivot_longer(names_to = "site", 
               values_to = "residue", 
               cols = c(`1`:`9`, `10`, `11`:`20`)) %>%
  relocate(site, .after = uniprot_id) %>%
  filter(residue %in% c("S", "T", "Y")) 
  

#The prediction algorithm handles sites in two groups, (S and T) and Y.
potential_sites_ST <- potential_sites %>% prepare_sites(c("S","T"), sp = "H")
potential_sites_Y <- potential_sites %>% prepare_sites("Y", sp = "H")

#Calculate number of substrates passed into deepphos. This is useful to draw graphs later.
substrates_in_deepphos <- sequence_table %>%
  filter(species == "H") %>%
  nrow()

#Write to csv to retain the data.
write.table(potential_sites_ST, "./data/processed/all_potential_ST.csv", quote = F, sep = ",", col.names = F, row.names = F)
write.table(potential_sites_Y, "./data/processed/all_potential_Y.csv", quote = F, sep = ",", col.names = F, row.names = F)

```

## Visualisation of consensus sequence characteristics

<!-- Part 1: General consensus sequence  -->

``` {r consensus-calculations}
#Categorise plots to represent in consensus sequences.
casp1H_data <- sequence_table %>% filter(cleaved_by == 1 & species == "H")
casp1M_data <- sequence_table %>% filter(cleaved_by == 1 & species == "M")
casp4_data <- sequence_table %>% filter(cleaved_by == 4)

#Quantity numbers for inline insertion to text: keeps values correct if data set changes.
casp_num <- nrow(sequence_table)
casp1H_num <- nrow(casp1H_data)
casp1M_num <- nrow(casp1M_data)
casp4_num <- nrow(casp4_data)
```

<!-- Figure references for visualisation segment -->

(ref:generic-cons-fig) Visualisation of inflammatory Caspase cleavage sites consensus categorised by chemistry, and position 10-11 represents the site of cleavage. A: all Caspases (`r casp_num` sites), B: Caspase-4 (`r casp4_num`), C: human Caspase-1 (`r casp1H_num`), D: murine Caspase-1 (`r casp1M_num`).

(ref:generic-h-fig) Representation of consensus accross `r casp1H_num` human Caspase-1 cleavage sites, coloured by relative hydrophobicity.

(ref:species-figure) Simple representation of assessment of substrate P4-P1 conservation in model organsisms (Ape = *P. troglodytes*, Human =  *H. sapiens*, Mouse = *M. musculus*, Zebrafish = *D. rerio*. A) `r casp1H_num` sites cleaved by human Caspase-1. B) `r casp1M_num` sites cleaved by murine Caspase-1.

<!-- End references segement -->

The acquired database of inflammatory caspase substrates was tidied into an amenable format, and cleavage site consensus interpreted with ggseqlogo [@wagih_2017]. 

Amino acids were categorised by chemical properties- acidity/basicity, hydrophobicity/polarity, and visualised in four plots: all `r casp_num` inflammatory caspase substrates, `r casp1H_num` human Caspase-1 substrates, `r casp1M_num` murine Caspase-1 substrates and `r casp4_num` human Caspase-4 substrates. Human Caspase-5 and murine Caspase-11 substrate consensus is not presented as few substrates have been recorded. 

```{r consensus-fig, fig.width = 6, out.width = "70%", fig.cap = "(ref:generic-cons-fig)"}

#Draw plots for consensus sequences. Standard presentation is using bits, but there is not much of a pattern here (that's the focus of the work anyway) so probability presentation looks a lot better.
all_casp <- ggseqlogo(sequence_table$sequence, seq_type = "aa", method = "prob") +
  theme()
casp1H <- ggseqlogo(casp1H_data$sequence, seq_type = "aa", method = "prob")
casp1M <- ggseqlogo(casp1M_data$sequence, seq_type = "aa", method = "prob")
casp4 <- ggseqlogo(casp4_data$sequence, seq_type = "aa", method = "prob")

#Present consensus sequence plots in grid using patchwork. Tags correspond to figure caption.
((all_casp + casp4) / (casp1H + casp1M)) / guide_area() +
  plot_annotation(tag_levels = "A") +
  plot_layout(guides = 'collect') 

```

<!-- Part 2: Example consensus sequences under different properties -->

Visualisations shown in Figure \@ref(fig:consensus-fig) demonstrate the lack of an apparent pattern in the consensus sequence, with the exception of an aspartate (**D**), or minorly glutamate (**E**), residue at the cleavage site at position 10. 

It should be noted that the studies comprising this data set did observe some sites with other residues in this position, though they were deliberately excluded from the compiled data set as there is insufficient experimental evidence for cleavage at sites other than **D** and **E**. These observations could reasonably be due to experimental artefacts such as contamination with other proteases such as cathepsins. 

Regardless, the observed results diverge greatly from the traditional dogma of DEVD cleavage sites for caspases that would lie at P7-P10 in Figure \@ref(fig:consensus-fig). Site chemistry also follows no discernible pattern, nor does a hydrophobicity scale of human Caspase-1 sites, the largest sample in the data set (Figure  \@ref(fig:characteristics-fig)).

``` {r characteristics-fig, out.width = "60%", fig.cap = "(ref:generic-h-fig)"}

#Present human caspase 1 by hydrophobicity.
ggseqlogo(casp1H_data$sequence, seq_type = "aa", method = "prob", col_scheme = "hydrophobicity")

```


Rationally, there is a factor other than local primary sequence chemistry explaining the identification of cleavage sites by inflammatory caspases, such as higher-order protein structure of post-translational modification.

Visualisation of the consistency of substrate P4-P1 residues between model species (Figure \@ref(fig:species-fig)) shows a high degree of conservation. 

This suggests that the amino acid residues surrounding the cleavage site are important, despite the general inconsistency of their chemistry (Figure \@ref(fig:consensus-fig)). Post-translational modifications are therefore an ideal candidate for investigation.


``` {r species-fig, fig.cap = "(ref:species-figure)"}

#Custom function to generate stacked bar charts representing sequence conservation.
casp1H_count <- count_species(casp1H_data)
casp1M_count <- count_species(casp1M_data)

#Present species diversity plots together using patchwork
casp1H_count + casp1M_count +
  plot_annotation(tag_levels = "A") +
  plot_layout(guides = 'collect') 

  
```



## Phosphate site analysis

<!-- Figure references for phosphate segment -->

(ref:frequency-figure) Representations of phosphorylation prediction results (score threshold `r phosphate_threshold`) amongst a sample of `r substrates_in_deepphos` human inflammatory Caspase substrates. A) Plot of prevelance of possible phosphorylated residues within the data set. B) Evaluation of the strength of phosphate prediction scores.

Position 10 is the cleavage site (D/E). B) 

<!-- End references section -->

Some proteomic analysis performed on apopototic caspases has suggested that phosphorylation at cleavage sites can impact the efficiency of proteolysis [@dix_2012]. It is possible that post-translational phosphorylation, which occurs at Serine (**S**), Threonine, (**T**) and Tyrosine (**Y**) residues.

```{python deep-phos}
#Suppress warnings generated by future deprecated libraries
import warnings
warnings.filterwarnings('ignore')

#Load forked/modified deepphos code
from deepphos import predict

#Run deepphos predictions
predict.predict_for_deepphos('./data/processed/all_potential_ST.csv', "ST")
predict.predict_for_deepphos('./data/processed/all_potential_Y.csv', "Y")

```

```{r phosphate-calculations}

#Read in generated data 
fileST <- "./data/processed/general_ST_prediction_phosphorylation.txt"
fileY <- "./data/processed/general_Y_prediction_phosphorylation.txt"

#ST and Y sets have to be separated for analysis, they can be put back together now.
# Filter by score (0-1) cut off point. 0.5 is standard.
processed_sites <- read.table(fileST) %>%
  full_join(read.table(fileY)) %>%
  setNames(c("Accession", "Pos", "Score")) %>%
  filter(Score >= phosphate_threshold)

#Count sequence positions that have a phosphorylable residue with score > cutoff.
# Obtain his number as a proportion of total substrates.
# This will be put in a bar chart to show the % of sites in that position that are phosphorylated
site_frequency <- processed_sites %>% 
  select(Pos) %>%
  count() %>%
  mutate(proportion = freq / substrates_in_deepphos)

#Get average scores to make a chart comparing phosphorylation strength in each position.
# Also get standard error by anonymous function as it's only done once. 
weighted_scores <- processed_sites %>% 
  aggregate(Score ~ Pos, ., mean)
weighted_scores$se <- aggregate(Score ~ Pos, processed_sites, function(x) sd(x) /sqrt(length(x)))[2]

#Numbers for inline code
mean_frequency <- site_frequency$proportion %>% mean() %>% round(3)
max_frequency <- site_frequency$proportion %>% max() %>% round(3)
max_position <- site_frequency[site_frequency$proportion == max(site_frequency$proportion),]$Pos
freq_sd <- site_frequency$proportion %>% sd() %>% round(3)
```

Data was tidied into an amenable format for analysis with a modified fork of phosphate site prediction model, DeepPhos which was assesed to be capable of identification of previously unknown phosphate sites [@luo_2019]. `r substrates_in_deepphos` human inflammatory Caspase substrates were processed using the DeepPhos prediction model against a threshold score of **`r phosphate_threshold`** (measured between 0 and 1). Results were categorised by position in the sequence and represented in Figure \@ref(fig:frequency-fig).

Position 10 represents the cleavage site (**D**/**E**), explaining the lack of any predicted phosphorylation sites at this position. An unexpectedly high number proportion of positions had prevalent phosphorylation, at a mean prevalence of `r mean_frequency` (n = `r substrates_in_deepphos`, s.d. `r freq_sd`), the greatest of which was position `r max_position` with a predicted phosphorylation frequency of `r max_frequency`.

```{r frequency-fig, fig.width = 6, fig.height = 2, fig.cap = "(ref:frequency-figure)"}

#Draw frequency bar plot. expand makes the bars start on the X axis.
frequency_graph <- ggplot(site_frequency, aes(x = Pos, y = proportion)) +
  geom_bar(stat = "identity", fill="#85ca5d", color = "black") +
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  xlab("Position") +
  ylab("Proportion") +
  scale_x_continuous(breaks = seq(1, 20, by = 1)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.4))

#Draw mean score evaluation bar plot.
score_graph <- ggplot(weighted_scores, aes(x = Pos, y = Score)) +
  geom_bar(stat = "identity", fill="#E0BBE4", color = "black") +
  geom_errorbar(aes(ymin = Score - se$Score, ymax = Score + se$Score), width=.2,
                 position=position_dodge(.9)) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  xlab("Position") +
  ylab("Mean Score") +
  scale_x_continuous(breaks = seq(1, 20, by = 1)) +
  scale_y_continuous(expand = c(0, 0), breaks = seq(0, 1, by = 0.2), limits = c(0, 1))
  
frequency_graph + score_graph
```

Also shown in Figure \@ref(fig:frequency-fig)

indication of the accuracy of computation of the mean.

# References
<!-- Comment required for references section to number in knitted output -->

